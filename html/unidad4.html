<!DOCTYPE html>
<html>
	<html lang="es">
	<head>
	<!--Titulo-->
		<title>Ambiente de Servicios</title>
		<!--Caracteres especiales-->
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE-edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!--Conexion con la hoja de estios y tipos de letra-->
		<link rel="stylesheet" type="text/css"	href="..\css\style.css" media="screen"/>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com">
		<link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300&family=Koulen&display=swap" rel="stylesheet">
	</head>
	<body class="cuerpo">
	<!--Div con boton del menu-->
		<div class="hamburger hamburger--spring" onclick="muestra()">
		<div class="hamburger-box">
		  <div class="hamburger-inner"></div>
		</div>
	  </div>
	  
	  <!--Menu desplegable-->
	  <nav class="nav" id="switch" >
			<ul class="list">
			
				<li class="list__item">
				<div class="list__button"><a href="./Inicio.html" class="nav__link">Inicio</a></div>
				
				</li>
				
				<li class="list__item list__item--click">
					<div class="list__button list__button--click">
					<a href="#" class="nav__link">Unidad 1</a>
					<img src="../media/img/arrow.svg" class="list__arrows">
					</div>
					
					<ul class="list__show">
						<li class="list__inside">
							<a href="./unidad1.html" class="nav__link nav__link--inside">Tipos de Arquitectura</a>
						</li>
						<li class="list__inside">
							<a href="./unidad11.html" class="nav__link nav__link--inside">Arquitectura Segmentada</a>
						</li>
						<li class="list__inside">
							<a href="./unidad12.html" class="nav__link nav__link--inside">Multiprocesamiento</a>
						</li>
						<li class="list__inside">
							<a href="./unidad13.html" class="nav__link nav__link--inside">Analisis de componentes</a>
						</li>
						</li>
						<li class="list__inside">
							<a href="./unidad14.html" class="nav__link nav__link--inside">CPU</a>
						</li>
						<li class="list__inside">
							<a href="./unidad15.html" class="nav__link nav__link--inside">ALU</a>
						</li>
					</ul>
				</li>
				
				<li class="list__item list__item--click">
					<div class="list__button list__button--click">
					<a href="#" class="nav__link">Unidad 2</a>
					<img src="../media/img/arrow.svg" class="list__arrows">
					</div>
					
					<ul class="list__show">
						<li class="list__inside">
							<a href="./unidad2.html" class="nav__link nav__link--inside">Unidad de control</a>
						</li>
						<li class="list__inside">
							<a href="./unidad21.html" class="nav__link nav__link--inside">Registros CPU</a>
						</li>
						<li class="list__inside">
							<a href="./unidad22.html" class="nav__link nav__link--inside">Buses</a>
						</li>
						<li class="list__inside">
							<a href="./unidad23.html" class="nav__link nav__link--inside">Memoria</a>
						</li>
						<li class="list__inside">
							<a href="./unidad24.html" class="nav__link nav__link--inside">Entrada/Salida</a>
						</li>
					</ul>
					
				</li>
				
				<li class="list__item list__item--click">
					<div class="list__button list__button--click">
					<a href="#" class="nav__link">Unidad 3</a>
					<img src="../media/img/arrow.svg" class="list__arrows">
					</div>
					
					<ul class="list__show">
						<li class="list__inside">
							<a href="./unidad3.html" class="nav__link nav__link--inside">Ciclo de instrucciones</a>
						</li>
						<li class="list__inside">
							<a href="./unidad31.html" class="nav__link nav__link--inside">Modos de direccionamiento</a>
						</li>
						<li class="list__inside">
							<a href="./unidad32.html" class="nav__link nav__link--inside">Chipset</a>
						</li>
						<li class="list__inside">
							<a href="./unidad33.html" class="nav__link nav__link--inside">Ambiente de Servicio</a>
						</li>
					</ul>
					
				</li>
				
				<li class="list__item list__item--click">
					<div class="list__button list__button--click">
					<a href="#" class="nav__link">Unidad 4</a>
					<img src="../media/img/arrow.svg" class="list__arrows">
					</div>
					
					<ul class="list__show">
						<li class="list__inside">
							<a href="./unidad4.html" class="nav__link nav__link--inside">Ambientes de Servicio</a>
						</li>
						<li class="list__inside">
							<a href="./unidad41.html" class="nav__link nav__link--inside">Paralelismo</a>
						</li>
						<li class="list__inside">
							<a href="./unidad42.html" class="nav__link nav__link--inside">Sistemas de memoria</a>
						</li>
						<li class="list__inside">
							<a href="./unidad43.html" class="nav__link nav__link--inside">Memoria Distribuida</a>
						</li>
					</ul>
					
				</li>
				
			</ul>
		</nav>
		<!--Div para el titulo-->
		<div class="sup">
			<center class="titulo">Arquitectura de computadoras</center>
		</div>
		
		<div class="info1">
		 <font class="titulos">Ambiente de Servicios.</font><br>
		</div>
		<div class="desc">
	La computación paralela es una forma de cómputo en la que muchas  instrucciones se ejecutan simultáneamente, operando sobre el  principio de que problemas grandes, a menudo se pueden dividir en  unos más pequeños, que luego son resueltos simultáneamente (en  paralelo). Hay varias formas diferentes de computación paralela:  paralelismo a nivel de bit, paralelismo a nivel de instrucción,  paralelismo de datos y paralelismo de tareas. El paralelismo se ha  empleado durante muchos años, sobre todo en la computación de  altas prestaciones, pero el interés en ella ha crecido últimamente  debido a las limitaciones físicas que impiden el aumento de la  frecuencia. Como el consumo de energía y por consiguiente la  generación de calor de las computadoras constituye una  preocupación en los últimos años, la computación en paralelo se ha  convertido en el paradigma dominante en la arquitectura de  computadores, principalmente en forma de procesadores  multinúcleo.
			<br><br>
			Los programas informáticos paralelos son más difíciles de escribir  que los secuenciales, porque la concurrencia introduce nuevos tipos  de errores de software, siendo las condiciones de carrera los más  comunes. La comunicación y sincronización entre diferentes  subtareas son algunos de los mayores obstáculos para obtener un  buen rendimiento del programa paralelo. La máxima aceleración  posible de un programa como resultado de la paralelización se  conoce como la ley de Amdahl. 
			<br><br> <h3>Ley de Amdahl y ley de Gustafson </h3> <br>
			Idealmente, la aceleración a partir de la paralelización es lineal,  doblar el número de elementos de procesamiento debe reducir a la  mitad el tiempo de ejecución y doblarlo por segunda vez debe  nuevamente reducir el tiempo a la mitad. Sin embargo, muy pocos  algoritmos paralelos logran una aceleración óptima. La mayoría  tienen una aceleración casi lineal para un pequeño número de  elementos de procesamiento, y pasa a ser constante para un gran  número de elementos de procesamiento. 
			La aceleración potencial de un algoritmo en una plataforma de  cómputo en paralelo está dada por la ley de Amdahl, formulada  originalmente por Gene Amdahl en la década de 1960. Esta señala  que una pequeña porción del programa que no pueda paralelizarse  va a limitar la aceleración que se logra con la paralelización. Los  programas que resuelven problemas matemáticos o ingenieriles  típicamente consisten en varias partes paralelizables y varias no  paralelizables (secuenciales).
			La ley de Gustafson es otra ley en computación que está en estrecha  relación con la ley de Amdahl. Ambas leyes asumen que el tiempo  de funcionamiento de la parte secuencial del programa es  independiente del número de procesadores. La ley de Amdahl  supone que todo el problema es de tamaño fijo, por lo que la  cantidad total de trabajo que se hará en paralelo también es  independiente del número de procesadores, mientras que la ley de  Gustafson supone que la cantidad total de trabajo que se hará en  paralelo varía linealmente con el número de procesadores. 
			Dependencias. <br>
			Entender la dependencia de datos es fundamental en la  implementación de algoritmos paralelos. Ningún programa puede  ejecutar más rápidamente que la cadena más larga de cálculos  dependientes (conocida como la ruta crítica), ya que los cálculos que  dependen de cálculos previos en la cadena deben ejecutarse en  orden. Sin embargo, la mayoría de los algoritmos no consisten sólo  de una larga cadena de cálculos dependientes; generalmente hay  oportunidades para ejecutar cálculos independientes en paralelo. 
			Sea Pi y Pj dos segmentos del programa. Las condiciones de  Bernstein describen cuando los dos segmentos son independientes y  pueden ejecutarse en paralelo. Para Pi, sean Iitodas las variables de  entrada y Oilas variables de salida, y del mismo modo para Pj. Pi y  Pj son independientes si satisfacen.
			<br><br>
			<h3>Ejecución paralela. </h3><br>
			Una violación de la primera condición introduce una dependencia de  flujo, correspondiente al primer segmento que produce un resultado  utilizado por el segundo segmento. La segunda condición representa  una anti-dependencia, cuando el segundo segmento (Pj) produce una  variable que necesita el primer segmento (Pi). La tercera y última  condición representa una dependencia de salida: Cuando dos  segmentos escriben en el mismo lugar, el resultado viene del último  segmento ejecutado.
			Condiciones de carrera, exclusión mutua, sincronización, y  desaceleración paralela. 
			Las subtareas en un programa paralelo a menudo son llamadas hilos.  Algunas arquitecturas de computación paralela utilizan versiones  más pequeñas y ligeras de hilos conocidas como hebras, mientras  que otros utilizan versiones más grandes conocidos como procesos.  Sin embargo, «hilos» es generalmente aceptado como un término  genérico para las subtareas. Los hilos a menudo tendrán que  actualizar algunas variables que se comparten entre ellos. Las  instrucciones entre los dos programas pueden entrelazarse en  cualquier orden. 
			Las aplicaciones a menudo se clasifican según la frecuencia con que  sus subtareas se sincronizan o comunican entre sí. Una aplicación  muestra un paralelismo de grano fino si sus subtareas deben  comunicase muchas veces por segundo, se considera paralelismo de  grano grueso si no se comunican muchas veces por segundo, y es  vergonzosamente paralelo si nunca o casi nunca se tienen que  comunicar.  
			Aplicaciones vergonzosamente paralelas son consideradas las más  fáciles de paralelizar. <br>
			Grano de paralelismo. <br>
			Muy grueso: Programas. <br>
			Grueso: Subprogramas, tareas. <br>
			Fino: Instrucción. <br>
			Muy fino: Fases de instrucción.<br>
			Modelos de consistencia. <br>
			Los lenguajes de programación en paralelo y computadoras paralelas  deben tener un modelo de consistencia de datos también conocido  como un modelo de memoria. <br>
			El modelo de consistencia define reglas para las operaciones en la  memoria del ordenador y cómo se producen los resultados. <br>
			Uno de los primeros modelos de consistencia fue el modelo de  consistencia secuencial de Leslie Lamport. La consistencia  secuencial es la propiedad de un programa en la que su ejecución en  paralelo produce los mismos resultados que un programa secuencial.  Específicamente, es un programa secuencial consistente si "... los  resultados de una ejecución son los mismos que se obtienen si las  operaciones de todos los procesadores son ejecutadas en un orden  secuencial, y las operaciones de cada procesador individual aparecen  en esta secuencia en el orden especificado por el programa".
			Taxonomía de Flynn. <br>
			Single Instruction, Single Data (SISD).<br> 
			Hay un elemento de procesamiento, que tiene acceso a un único  programa y a un almacenamiento de datos. En cada paso, el  elemento de procesamiento carga una instrucción y la información  correspondiente y ejecuta esta instrucción. El resultado es guardado  de vuelta en el almacenamiento de datos. Luego SISD es el  computador secuencial convencional, de acuerdo al modelo de von  Neumann.
			<br><br>
			Multiple Instruction, Single Data (MISD). <br>
			Hay múltiples elementos de procesamiento, en el que cada cual tiene  memoria privada del programa, pero se tiene acceso común a una  memoria global de información. En cada paso, cada elemento de  procesamiento de obtiene la misma información de la memoria y  carga una instrucción de la memoria privada del programa. Luego,  las instrucciones posiblemente diferentes de cada unidad, son  ejecutadas en paralelo, usando la información (idéntica) recibida  anteriormente. Este modelo es muy restrictivo y no se ha usado en  ningún computador de tipo comercial.
			<br><br>
			Single Instruction, Multiple Data (SIMD). <br>
			Hay múltiples elementos de procesamiento, en el que cada cual tiene  acceso privado a la memoria de información (compartida o  distribuida). Sin embargo, hay una sola memoria de programa, desde  la cual una unidad de procesamiento especial obtiene y despacha  instrucciones. En cada paso, cada unidad de procesamiento obtiene  la misma instrucción y carga desde su memoria privada un elemento  de información y ejecuta esta instrucción en dicho elemento.  Entonces, la instrucción es síncronamente aplicada en paralelo por  todos los elementos de proceso a diferentes elementos de  información. Para aplicaciones con un grado significante de  paralelismo de información, este acercamiento puede ser muy  eficiente. Ejemplos pueden ser aplicaciones multimedia y algoritmos  de gráficos de computadora.
			<br><br>
			Multiple Instruction, Multiple Data (MIMD). <br>
			Hay múltiples unidades de procesamiento, en la cual cada una tiene  tanto instrucciones como información separada. Cada elemento  ejecuta una instrucción distinta en un elemento de información  distinto. Los elementos de proceso trabajan asíncronamente. Los  clusters son ejemplo son ejemplos del modelo MIMD.
		</div>
		
		<script src="..\js\main.js"></script>
	</body>
</html>